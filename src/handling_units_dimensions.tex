\documentclass{article}
\usepackage{url}

\begin{document}

\title{What is 1~kg + 0.1~m? Handling dimensions and units of measure in a program}

\author{Arjen Markus, Brad Richardson}

\maketitle

\abstract
Most, if not all, programs that perform numerical computations of some kind or other need to deal with
the units of measure in which their variables are expressed. Many solutions for the general problem
have been proposed, but the problem is more difficult than it looks at first sight. In this article we
aim to give insight in the various aspects and what the proposed solutions can and cannot do.

\section{Introduction}
In almost all programs that perform numerical computations the question arises whether the units of measure have
been treated correctly. For instance: the sum of a variable that represents a mass and a variable that represents
a length is undefined, yet for most computer languages, the variables would probably be simple floating-point
numbers and it is the burden of the programmer to make sure that they are used in the right way, that is,
two masses can be added and you can multiply or divide a mass by a length, but the sum or the difference has no meaning
and so should not pop up in the source code.

Various solutions have been proposed for many different programming languages, but there does not seem to be a
silver bullet (cf.\ Section \ref{ExistingSolutions}). Examination of the publications on these solutions shows several
classes of solutions:
\begin{itemize}
\item
Variables in the source code are decorated with static features that represent the units of measure
\cite{DimensionalityCheckingAda, BlogAdaPhysicalUnitsGeneric, QuaffFortranPackage, PhysicalEngineeringUnitsN2113}. The burden is
on the programmer to provide these features. Depending on the language they are extensions of simple floating-point numbers
or specific additions to the language itself, requiring support from the language tools (notably compilers and linkers).
\item
A preprocessor/static analyser is developed that helps identify violations of the arithmetic rules for units of measure
\cite{SimConFPTCheckingUnits}.
Typically, the programmer annotates the variables via special comments, so that the analysis can be refined.
\item
Rather than a static checker in the form of a compiler or a preprocessor, all (relevant) variables are defined to have
a dynamic set of dimensions and the checks are made at run-time \cite{PhysUnitsPetty}. This clearly impacts the performance, but makes for
a light-weight solution, because the developer of the package can use the standard facilities offered by the programming
language.
\end{itemize}

Surprisingly, however, while the publications discuss in more or less detail the techniques used and how the user can use
the solutions to their benefit, none seem to discuss the characteristics of units of measure and how these play a role
in the average program. In fact, the distinction between \emph{dimension} and \emph{unit} is seldom made explicitly. This
article is meant to explore precisely these characteristics and how they influence the design of a programming solution.


\section{Dimensions and units}
First of all, we need to be clear about what a dimension is and what a unit is. In science and engineering we typically
rely on the \emph{Syst\`eme International} for defining dimensions and units, but in finance or economics other systems
are of importance. But let us begin with the SI units -- or dimensions.

A dimension is the general aspect of some measure. Here is an arbitrary definition found on the Internet:
"a measurable extent of a particular kind, such as length, breadth, depth, or height." The SI distinguishes seven
basic dimensions: mass (M), length (L), absolute temperature ($\Theta$), time (T), amount of substance (N), electric current (I)
and luminous intensity (J). Dimensions can be combined, for instance a surface area would be a squared length -- L$^2$, or
a density would be mass divided by length to the power three -- M/L$^3$.

Many solutions that help verifying that the program code does the right thing as far as units in the expressions are concerned
limit themselves to \emph{dimensional analysis}. Small wonder, because the \emph{units of measure} in which the actual
value of a quantity is expressed, are legion: common units for length are meter, centimeter, inch, foot, kilometer, mile and
so on. Each has the dimension of length, but each is numerically different. So, whether the solution allows you to work with
expressions like 1~m~+~10~inch very much depends on whehther it does \emph{unit conversions} or not.


\section{Design questions}
The requirements we can deduce from available use cases and from general considerations can be divided
into two categories. On the one hand we have requirements that are necessary for the feature to be at all useful, and
on the other hand we have requirements that are nice to have but are not actually essential or might
hinder some usages.

Here is an overview of both types:

\vspace{\baselineskip}
\noindent \emph{Requirement 1 (Diagnosis and error reporting):}
It is essential that violations of the rules that gouvern units and dimensions be clearly identified in the
source code. Suppose the program calls a routine that expects an acceleration as argument but gets a velocity.
When this mistake can be detected \emph{statically}, the reported error can pinpoint the exact location. If
a variable receives its dimension/unit as a result of some calculation, it can be very hard to identify that
location.

Error reporting should be as accurate as possible, both concerning the character and the location in the program.

\vspace{\baselineskip}
\noindent \emph{Requirement 2 (Flexibility in units):}
The feature must be able to deal with different units for the same dimension. A classical example is the use of
input in feet as the unit of length, where the program itself (or the library it uses) prefers meters. Similarly,
it will be important to produce output in suitable units.

\vspace{\baselineskip}
\noindent \emph{Requirement 3 (Flexibility in dimensions):}
The programmer should be able to define their own dimensions, not only units. This is important, because the \emph{SI}
dimensions are but a subset of the dimensions that are really in use. This could be within the context of
physical and chemical applications -- think of "ml oxygen per liter water" but also of financial dimensions.

\vspace{\baselineskip}
\noindent \emph{Requirement 4 (Arrays with units):}
If the feature does not support arrays whose elements have different dimensions/units of measure, then
certain use patterns are not possible. That may or may not be a breaking requirement for the feature.

\vspace{\baselineskip}
\noindent \emph{Requirement 5 (Static or dynamic units for variables):}
If the feature allows variables to have different units, depending on where they are used in the program, this
may hinder static analysis and it may also hide mistakes. If that is not allowed, variables will have to be
declared to have certain units and this puts an extra burden on the programmer.

\vspace{\baselineskip}
\noindent \emph{Requirement 6 (Static or dynamic units for function results and arguments):}
If the feature does not allow functions to take arguments with different units and produce results with units derived
from the arguments, it will be difficult to write a generally applicable library that can handle units consistently.
For instance, a library that solves differential equations will need to handle any conceivable units for the
dependent and independent variables. Writing a version for each unit separately is prohibitively expensive.

\vspace{\baselineskip}
\noindent \emph{Requirement 7 (Performance):}
There should not be any noticeable effect on the performance of a program that handles units versus the same program
that does not handle units explicitly, with a possible exception for input and output unit conversions. Of course, this
is met much easier by solutions that use static analysis than by solutions that check the units at run-time.

\vspace{\baselineskip}
\noindent \emph{Requirement 8 (Programming effort):}
While explicitly declaring the units of variables in a program will save a lot of debugging effort, the extra effort
should not get in the way of using the feature. This may mean that a pre=defined set of units be available, so that
a programmer does not need to start from scratch for each new program. Declaring the unit for a variable is inevitable,
but defining the units and possibly conversions between them ought to be a matter of supplying a suitable units library.


\section{Existing solutions}
\label{ExistingSolutions}

A survey of existing solutions finds that library and language built-in solutions fall broadly into three categories.
Each solution offers its own positive and negative aspects and trade-offs.
We will explore the strengths and weaknesses of each from the perspectives of a library writer, an application developer, and an end user.

\subsection{Define the units associated with a variable (i.e. meters, inches, etc.)}
\label{static-units}

This is the solution commonly used when such a facility is built-in to a language.
For example F\# has such a facility~\cite{FSharpUnitsofMeasure2020}, as does Ada~\cite{DimensionalityCheckingAda}.
The main benefit to such an approach is that once type-checking (or other static analysis) has been completed,
the dimensional information is no longer needed, and the information can be ignored at run-time.
This allows the possibility that such a solution incur no run-time overhead.
There are implementations in this category which are not built into the language,
for example the C++ library mp-units~\cite{mpunits}, the Rust library Dimensioned~\cite{RustDimensioned}, or the Nim library Unchained~\cite{SciNimUnchained},
which generally require more advanced templating or type system capabilities,
and can begin to blur the lines between this and the next category of solutions.

From the perspective of a library writer, there are two stances that one might take.
They could provide interfaces in only the units of their choice and be confident that they do not have any dimensional inconsistencies and incur no runtime overhead,
or they could be quite frustrated that in order to provide an interface to a wide range of applications they must either duplicate their algorithms for all conceivably useful combinations of units, or work around the units system and lose the compile time safety it provides.

An application developer will generally find this solution quite agreeable.
It provides compile-time guarantees that their dimensional analysis is correct.
If a library provides interfaces in the units they desire, they can be confident that the library will not incur unnecessary run-time overhead,
and if it does not, the places in which they must do explicit unit conversions will usually be fairly limited in scope.
It is also a natural extension of how many application developers (usually domain experts) think about their solutions,
i.e. that the numbers in their formulas may change, but the units do not.

End users of some applications may find this solution somewhat inflexible.
It may be inconvenient for them to input values to the program in the units dictated by the application developer,
but it would also be quite difficult for the application to deal with values input in different units,
as it is impossible to declare a variable that does not know its units until run-time.
Similarly it would be difficult for the program to allow the user to request outputs in different units.

Defining the units associated with a variable can be provide a large amount of compile-time checking,
incurs little to no run-time overhead, and can be a natural solution for application developers.
However, it can often be quite inflexible in ways that make development and maintenance difficult for library writers,
and can result in programs with inconvenient input specifications.
Solutions of this kind are therefore most suitable for prototype development,
but can be a long term maintenance burden for larger scale, long lived applications.

\subsection{Define the dimension of a variable (i.e. length, force, etc.)}
\label{static-dimensions}

This category of solutions is not taken as frequently as the other two.
It is usually implemented as a library, but can be an expensive library to develop and maintain.
The development expense comes from needing to define types and units for all possible dimensions,
as well as the mathematical operations allowed between them.
The main benefit of this approach is that it provides additional flexibility sufficient for most library writers
and application end users, without a large amount of run-time overhead.
The run-time overhead comes in the form of either keeping track of a value's units,
or implicitly performing unit conversions at the time of value creation.
Example libraries that would fit this category are quaff~\cite{QuaffFortranPackage} and UnitsNet~\cite{Larsen2021}.

From the perspective of a library writer, this solution strikes a nice balance.
It relieves most, if not all, of the burden of providing interfaces to their algorithms for all conceivably useful combinations of units without needing to work around the units system or the compile time safety it provides.
It does not completely eliminate duplication for algorithms that work for different dimensions however,
for example linear solvers which could be used to solve for stress or temperature depending on the dimensions of the inputs.

From the perspective of an application developer, this solution generally strikes the ideal balance.
It still provides compile-time guarantees that their dimensional analysis is correct,
does not incur significant run-time overhead,
and makes it easy to provide end users the flexibility of providing inputs and requesting outputs in whatever units are most convenient.
However, this solution will not be sufficient for more general purpose expression evaluators or calculators,
because even the dimension of a value will not be known until run-time.

End users will find this solution sufficient for most applications.
It will be easy for application developers to allow them to provide inputs in whatever units are most convenient,
and request outputs in whatever units they desire.
However, general expression evaluation and calculators with units will still not be feasible with this solution.

\subsection{Track the dimensions of variables at run time}
\label{dynamic-dimensions}

This category of solution is frequently used in library implementations.
The main benefit of the approach is its high degree of flexibility.
However, it generally comes at the expense of a high amount of run-time overhead,
because all dimensions and units are tracked, checked, and simplified at run-time.
Example libraries that fit this category are more common in interpreted languages,
for example the Python library pint~\cite{Grecco2021} or the Ruby library Ruby Units~\cite{Olbrich2021}.

From the perspective of a library writer, this solution eliminates any extra development and maintenance overhead,
but still ensures that users of the library have consistent units.
Unfortunately, it comes at the expense of significant run-time overhead.

From the perspective of an application developer, it practically eliminates all of the units checking they were after.
Any errors in the units will be found, but only at run-time, possibly far from the cause of the error.
It does however allow for the flexiblity to develop applications which do not even know the dimensionality of their inputs until run-time.

From the perspective of an end user, this solution is necessary for applications that perform general purpose calculations and expression evaluation with units.

\section{Use cases}
Within a typical program, be it engineering or economical, you will find different usage patterns:

\subsection*{Input/output}
The user should be able to provide the data in a convenient form, including a convenient unit. The program may work in meters,
but to specify the size of an atom in meters is not the most friendly possibility. Likewise for output.

\subsection*{General calculator}
As an extension of the requirement on flexible input and output, we may also want the program to support interactive use,
as in a general calculator. Feed it data with different units of length and it prints the sum in the unit of your choice.

\subsection*{Typical expressions}
Expressions in which the variables and constants have dimensions and consequently units of measure come in various
categories. Here are a few:

\vspace{\baselineskip}
\noindent \emph{Mathematical formulae}:

\noindent Consider the area of a circle:
\begin{equation}
    A = \pi R^2
\end{equation}
%
In this formula the radius $R$ has the dimension $L$ (length) and the area $A$ has the dimension $L^2$ (length squared). The
constant $\pi$ is essentially unitless. To deal with this formula, the system must either recognise that dimensions can
be multiplied, forming new combinations, or it must be told that both $L$ and $L^2$ are allowed.

But if you were to calculate the mass of a cylinder from its radius $R$, height $H$ and the density of the material $\rho$
via the slightly more complicated formula:
\begin{equation}
    M = \rho \pi R^2 L
\end{equation}
\noindent the system now has to deal with a dimension $M L^{-3}$ for the density $\rho$ as well as $L^2$ and $L$. Depending on the way the
formula is programmed and the way the compiler (or the executable program) handles this expression, we may encounter the
following intermediate results:

\vspace{\baselineskip}
\begin{tabular}{ll}
\hline
Density multiplied by length                       &   $M L^{-3} \cdot L$   \\
Density multiplied by length squared               &   $M L^{-3} \cdot L^2$ \\
Density multiplied by length cubed                 &   $M L^{-3} \cdot L^3$ \\
Length squared multiplied by length                &   $L^2 \cdot L$        \\
Density times length squared multiplied            &   $(M L^{-1}) \cdot L$ \\
by length                                          &                        \\
\hline
\end{tabular}
\vspace{\baselineskip}

\noindent and possibly others. In short: expressions that involve variables and constants with units of measure can generate
new combinations of dimensions. With a na\"ive implementation this can easily result in tens of thousands
combinations \cite{UnitsOfMeasureFortran}.

An obvious seeming solution is to define a specific type or an attribute representing the desired unit or
dimension:

\begin{verbatim}
    type(length_dim)  :: radius, length
    type(density_dim) :: density
    type(mass_dim)    :: mass
    real, parameter   :: pi = 3.1415926 ! Approximately

    mass = pi * density * radius ** 2 * length
\end{verbatim}

At least the operations \emph{multiply} and \emph{exponentiation} should be overloaded.
For the above formula you would also need to represent \emph{density * length} because a \emph{density} gets
multiplied by a \emph{length}, as well as any of the other combinations.

While in a given program there will be a finite number of combinations, some support from the compiler or analyser
would help: the tool in question would then gather all the units/dimensions for each term, rather than for each
combination separately and create the final unit/dimension. This is essentially what the package by Petty
does \cite{PhysUnitsPetty}: for each variable of the type \verb+type(preal)+ the exponents of the basic SI dimensions are traced, so that the
multiplication of a \emph{density} [M L$^{-3}$] and a length [L] results in an intermediate variable with dimension
[M L$^{-2}$]. Thus there is only a single user-defined type, which stores the exponents of the seven fundamental units.

It may seem that the dimensions are raised to integer powers, but rational powers can also arise, as in the period $T$ for
a harmonic pendulum:
\begin{equation}
    T = 2 \pi \sqrt{\frac{l}{g}}
\end{equation}

\vspace{\baselineskip}
\noindent \emph{Empirical formulae}:

\noindent While mathematical formulae are usually rather "crisp", with clear definitions of exponents and constants, that
is not so for empirical or semi-empirical formulae. Here is an example, a relation between the water level $h$ and the
flow rate $Q$ in some unspecified river:
%
\begin{equation}
    Q = 5.3 \cdot h^{2.7}
\end{equation}
%
The water level must be expressed in meters relative to a reference level and the flow rate is in $m^3/s$. If you were
to express the water level in fathoms instead, the result would be completely wrong. It would even be wrong if you
expressed the water level relative to another reference level than implied in the formula.

This type of formula can only be used with a lot of background information, information that may be found in the
comments or the documentation or simply in the heads of the users of the program, because they have been working with
it for years.

A correct way to write this formula is:
%
\begin{equation}
    Q = Q_0 \cdot \bigl (\frac{h}{h_{norm}} \bigr)^{2.7}
\end{equation}
%
\noindent where $Q_0 = 5.3~m^3/s$ and $h_{norm} = 1~m$, a normalisation factor, rendering the value to exponentiated
dimensionless. Still, this leaves implicit the reference level against which the water level is measured.

\vspace{\baselineskip}
\noindent \emph{Chemical formulae}:

\noindent According to the Syst\`eme Internationale (\emph{SI}) amounts of a substance are to be expressed in \emph{moles}, the number of molecules or atoms
or ions divided by Avogrado's number. This is a very convenient way to do calculations regarding chemical reactions.
For instance, this equilibrium between CO$_2$ and HCO$_3^-$ in water:
\begin{equation}
    CO_2 + H_2O \rightleftharpoons HCO_3^- + H^+
\end{equation}
%
The reaction constant is (since the amount of water normally exceeds the amounts of the other substances by many
orders of magnitude, it is essentially constant and can be absorbed in the reaction constant):
\begin{equation}
    K = \frac{[CO_2]}{[HCO_3^-][H^+]} \rightarrow \textrm{mol}^{-1}
\end{equation}
%
\noindent but there are three molecules/ions involved, so actually three different molar units.

Other units that need to be considered are:
\begin{itemize}
\item
Using \emph{ml/l} as the unit for gas dissolved in water. In particular, the concentration of dissolved oxygen is
sometimes expressed in this unit. It should be interpreted as "milliliter of dissolved oxygen per liter of water".
\item
The concentration of salt in sea water, salinity, is expressed in units like \emph{ppt} (parts per thousand), \emph{psu}
(practical salinity units) or \emph{1e-3}. This latter is the official unit prescribed by the "CF conventions" organisation
\cite{CFConventionsStandardNames}.
Since it looks very much like a plain number, supporting something like that requires extra care, also on the part of
the programmer, one would think.
\end{itemize}

\vspace{\baselineskip}
\noindent \emph{Financial/economic expressions}:

\noindent As engineers with physical or chemical background we are used to thinking in terms of the SI dimensions and units, or
perhaps imperial units like inches and ounces. In other areas of computation very different dimensions are involved.
Consider the gross domestic product, GDP. It is expressed as the amount of currency per year. And the
exchange rates of dollars to euros or yens involve the ratio of two currencies. Formally, that may be a dimensionless
value, but you should not use the wrong way around. A unit checking mechanism therefore might be required to
distinguish the exchange rate dollar/euro from the rate euro/dollar.

But even seemingly dimensionless numbers require some care: the number of inhabitants of a city is a mere count without
a dimension, but it does not make sense to add a bare number like $100$ to it, unless that number also represents some
number of people.

And what to think of percentages? Combining two percentages $\alpha$ and $\beta$ should not be done by adding them, but by
a formula like:
\begin{equation}
    \gamma = ((1 + \frac{\alpha}{100}) \cdot (1 + \frac{\beta}{100}) - 1) \cdot 100\%
\end{equation}

\subsection*{Dimensional analysis}

The very least we may require from a solution for the problem we consider here is that it checks the dimensional correctness
of expressions. This means that the arithmetic for dimensions is checked and verified \cite{DimensionalAnalysis}:
\begin{itemize}
\item
Multiplication and division is possible with any combination of dimensions, but leads to a new combination.
\item
Addition and subtraction is possible only when the dimensions of the terms are identical.
\item
Exponentiation is -- in general -- limited to rational powers. One may argue whether, like in the case of empirical
formulae, exponentiation to some arbitrary power implicitly means the unit is ignored.
\item
Elementary functions as $sin$ and $log$ do not take arguments which have a dimension, though for the trigonometric functions
they are often interpreted in \emph{radians} and alternatives may exist for arguments expressed in \emph{degrees}.
\end{itemize}

Things become much more complicated if we also require conversion of units be taken into account. Quite apart from
the vast number of units that is in use for the various basic dimensions or the combined dimensions that are derived
from them, some units of measure do not adhere to the above general rules.

The first example is units of temperature other than \emph{kelvin}. Suppose you were to add a temperature of $10 ^\circ C$
and $20 ^\circ C$ -- or the same values in degrees Fahrenheit. The na\"ive result is $30 ^\circ C$, or about $303~K$, but if this was an
allowable operation, we could also convert the two terms first to kelvin and then the result would be quite different:
$ 283~K + 293~K = 776~K$. You can, however, subtract two temperatures and you can add a temperature and a temperature difference.

As a second example, take the \emph{decibel}, used among other things as a unit of sound. It is defined as ten times the
logarithm of the ratio of two values. Adding two values with the unit of decibel is quite ambiguous, as can be seen
by writing out the definitions:

\begin{eqnarray}
   dB_{a}   &=& 10 ~ \log \bigl ( \frac{V_1}{V_2} \bigr ) \\
   dB_{b}   &=& 10 ~ \log \bigl ( \frac{V_3}{V_4} \bigr ) \\
   dB_{a+b} &=& 10 ~ \log \bigl ( \frac{V_1 \cdot V_3}{V_2 \cdot V_4} \bigr )
\end{eqnarray}

The interpretation becomes awkward, unless there is a relation between the various values, like $V_2$ identical to $V_3$, in
which case the summation means an \emph{increase} of the original value.

Ideally, a programming solution for checking the dimensions (and units) used in a program would take all such considerations
into account.

\subsection*{State vector}
Some of the solutions that have been suggested define a variable to have a fixed unit or dimension. But that presents
a problem if you have an array of which each element can have a different dimension. Here is a simple example,
a (forced) harmonic oscillator:
\begin{equation}
    \frac{d^2 x}{dt^2} - kx = F(t)
\end{equation}

The system has two state variables, the position ($L$) and the velocity ($L T^{-1}$). It is natural to put these two
state variables into an array and solve the system of equations via a standard ODE solver:
\begin{verbatim}
    real :: x(2)

    x(1) = 1.0   ! Start position in [m]
    x(2) = 0.0   ! Start velocity in [m/s]

    do i = 1,times
        call solve( x, t, dt, func )
        write(*,*) t, x
    enddo
\end{verbatim}

\subsection*{Dynamic units of measure}
Another question that arises in every day programming practice is whether dimensions (or units) are static properties
of a variable or not. \cite{FPTSymbolLives} explicitly consider this possibility, as illustrated by the following
code fragment:

\begin{verbatim}
! Sort the tables by weight
change_f = .TRUE.
DO WHILE (change_f)
    DO i = 2, n
        IF (weight(i) < weight(i-1)) THEN
            temp = weight( i )
            weight( i ) = weight( i-1 )
            weight( i-1 ) = temp
            temp = height( i )
            height( i ) = height( i-1 )
            height( i-1 ) = temp
            change_f = .TRUE.
        ENDIF
    ENDDO
ENDDO
\end{verbatim}

The variable \verb+temp+ is used first as a weight ($M$) and then as a height ($L$). If the dimension of each variable were
a static property -- which allows checking at compile-time -- then this usage pattern would be prohibited. In the proposal
by \cite{PhysicalEngineeringUnitsN2113} a similar situation is described: here it is suggested to allow dimensionally polymorphic
functions that inherit the dimension of the result from their arguments. One example, mentioned in \cite{SimConFPTCheckingUnits},
is the \emph{maximum} function -- all of its arguments should have the same dimension (unit) and the result will be that dimension
(or, more precisely, unit).


%\section{Simple examples}
%\emph{Consider:}
%
%\begin{equation}
%   \frac{dC}{dt} = \frac{r}{H} (C_s - C) - k B
%\end{equation}
%\noindent
%\begin{tabular}{lll}
%$r$   & reaeration coefficient   & [$m/day$]    \\
%$H$   & depth                    & [$m$]        \\
%$C$   & concentration oxygen     & [$g/m^3$]    \\
%$C_s$ & saturation concentration & [$g/m^3$]    \\
%$k$   & decay rate BOD           & [$day^{-1}$] \\
%$B$   & concentration BOD        & [$g/m^3$]    \\
%\end{tabular}
%
%Compile-time checks:
%
%Depending on the way the formula is actually written and treated by the compiler, we get combinations of:
%\begin{itemize}
%\item
%Units [$m/day$] and [$m$]
%\item
%Units [$m/day$] and [$g/m^3$]
%\item
%Units [$m$] and [$g/m^3$]
%\item
%Units [$day^{-1}$] and [$g/m^3$]
%\end{itemize}
%
%Should the compiler simply gather the units from multiplications and divisions and determine a combined unit?
%
%What about alternative units? Can they be resolved in the same way, as long as there is a linear relationship? ([$mm$] and [$inch$])
%
%However:
%\begin{itemize}
%\item
%The first component is a position -- [$m$]
%\item
%The second component is a velocity -- [$m/s$]
%\end{itemize}
%
%
%\emph{Consider:}
%Units or dimensions of a more informal nature: gram chlorophyll per gram carbon.
%
%\emph{Consider:}
%The intermediate dimensions/units in an expression like that of the Reynolds number.
%
%
%\section{References}
\bibliographystyle{elsarticle-harv}
\bibliography{handling_units_dimensions}

\end{document}
